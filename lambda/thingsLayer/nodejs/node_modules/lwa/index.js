// Copyright Amazon.com, Inc. and its affiliates. All Rights Reserved.

// SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0

// Licensed under the Amazon Software License (the "License").
// You may not use this file except in compliance with the License.
// A copy of the License is located at

//   http://aws.amazon.com/asl/

// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

/*
************ Lambda Layer description *************
*
* This lambda layer exposes the APIs to store, retrieve and get refresh and
* access tokens from Amazon. These tokens are used for performing skill
* enablement activities (stored in skillsDB) or sending proactive updates to
* Alexa (stored in psuDB).
*
*/

const AWS = require('aws-sdk')
const https = require('https')
const docClient = new AWS.DynamoDB.DocumentClient()
const queryString = require('querystring')
const psuDB = process.env.PSU_TOKEN_DB
const skillsDB = process.env.SKILL_TOKEN_DB

/* Exports the API to get the list of all the users and their tokens
 * Returns an array of user and access tokens
 */
exports.getAllUsers = async () => {
  const params = {
    TableName: psuDB,
    ProjectionExpression: 'userID, refresh_token'
  }

  try {
    const users = []
    const usersDB = await docClient.scan(params).promise()
    console.log(JSON.stringify(usersDB.Items))
    usersDB.Items.foreach(async element => {
      const refreshToken = await retrieveTokenFromDB(skillsDB, element.userID)
      const data = await getAccessToken('refresh', refreshToken)
      const token = JSON.parse(data)
      console.log(token)
      users.push({ userID: element.userID, access_token: token.access_token })
      console.log(JSON.stringify(users))
    })
    return (users)
  } catch (e) {
    return (false)
  }
}

/* Exports the API to retrieve access token for performing skill related functions (enable, disable, getSkillStatus)
 * Returns access token for the user
 */
exports.getSkillsToken = async (userID) => {
  const refreshToken = await retrieveTokenFromDB(skillsDB, userID)
  if (refreshToken) {
    const data = await getAccessToken('refresh', refreshToken)
    const token = JSON.parse(data)
    return token.access_token
  } else { return false }
}

/* Exports the API for retrieveing token for sending proactive state updates
 * Returns access token for the user
 */
exports.getPsuToken = async (userID) => {
  const refreshToken = await retrieveTokenFromDB(psuDB, userID)
  if (refreshToken) {
    const data = await getAccessToken('refresh', refreshToken)
    const token = JSON.parse(data)
    return token.access_token
  } else { return false }
}

/* Exports the API for storing skill tokens */
exports.storeSkillsToken = async (userID, authCode) => {
  const token = await getAccessToken('code', authCode)
  const record = JSON.parse(token)
  record.userID = userID
  record.timeOfSample = new Date().toISOString()
  await storeTokenInDB(record, skillsDB)
}

/* Exports the API for storing PSU tokens */
exports.storePsuToken = async (userID, authCode) => {
  const token = await getAccessToken('code', authCode)
  const record = JSON.parse(token)
  record.userID = userID
  record.timeOfSample = new Date().toISOString()
  await storeTokenInDB(record, psuDB)
}

/* Internal API to retrieve refresh token from DynamoDB */
async function retrieveTokenFromDB (tableName, userID) {
  const params = {
    TableName: tableName,
    Key: {
      userID: userID
    }
  }
  try {
    const token = await docClient.get(params).promise()
    return (token.Item.refresh_token)
  } catch (e) {
    console.log(e)
    return (false)
  }
}

/* Internal API to store token in the DynamoDB table */
async function storeTokenInDB (record, tableName) {
  const params = {
    TableName: tableName,
    Item: record
  }
  try {
    const responseDB = await docClient.put(params).promise()
    return (responseDB)
  } catch (e) {
    console.log(e)
    return (false)
  }
}

/* Internal API to exchange auth code OR refresh token to get new access and refresh tokens */
function getAccessToken (type, token) {
  const params = {
    client_id: process.env.LWA_CLIENT_ID,
    client_secret: process.env.LWA_SECRET_KEY,
    redirect_uri: process.env.REDIRECT_URI
  }

  if (type === 'refresh') {
    params.grant_type = 'refresh_token'
    params.refresh_token = token
  } else if (type === 'code') {
    params.grant_type = 'authorization_code'
    params.code = token
  } else {
    return false
  }

  const body = queryString.stringify(params)

  const options = {
    host: 'api.amazon.com',
    path: '/auth/o2/token',
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'Content-Length': Buffer.byteLength(body)
    }
  }

  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      res.setEncoding('utf8')

      res.on('data', function (chunk) {
        resolve(chunk)
      })
      res.on('error', (e) => {
        reject(e.message)
      })
    })

    req.write(body)

    req.end()
  })
}
